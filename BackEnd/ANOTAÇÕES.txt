src/
â”œâ”€â”€ controllers/       # Controladores para lidar com as requisiÃ§Ãµes HTTP
â”‚   â””â”€â”€ users.js       # Controlador especÃ­fico para rotas relacionadas a usuÃ¡rios
â”œâ”€â”€ models/            # Modelos do Sequelize (representaÃ§Ã£o das tabelas do banco de dados)
â”‚   â””â”€â”€ jogador.js     # Modelo para a tabela Jogador
â”‚   â””â”€â”€ sala.js        # Modelo para a tabela Sala
â”œâ”€â”€ routes/            # DefiniÃ§Ã£o de rotas
â”‚   â””â”€â”€ users.js       # Rotas relacionadas a usuÃ¡rios
â”‚   â””â”€â”€ index.js       # Arquivo principal para consolidar todas as rotas
â”œâ”€â”€ services/          # LÃ³gica de negÃ³cios e manipulaÃ§Ã£o de dados
â”‚   â””â”€â”€ userService.js # ServiÃ§o para lÃ³gica de usuÃ¡rios
â”‚   â””â”€â”€ roomService.js # ServiÃ§o para lÃ³gica de salas
â”œâ”€â”€ middlewares/       # Middlewares para validaÃ§Ã£o, autenticaÃ§Ã£o, etc.
â”‚   â””â”€â”€ auth.js        # Middleware para autenticaÃ§Ã£o JWT
â”œâ”€â”€ db/                # ConfiguraÃ§Ãµes e migraÃ§Ãµes do banco de dados
â”‚   â”œâ”€â”€ migrations/    # Arquivos de migraÃ§Ã£o do Sequelize
â”‚   â””â”€â”€ config/        # ConfiguraÃ§Ãµes do banco de dados
â”œâ”€â”€ utils/             # FunÃ§Ãµes utilitÃ¡rias
â”‚   â””â”€â”€ logger.js      # FunÃ§Ã£o para logs
â”‚   â””â”€â”€ helpers.js     # FunÃ§Ãµes auxiliares
â””â”€â”€ app.js             # ConfiguraÃ§Ã£o principal do Express
â””â”€â”€ server.js          # InicializaÃ§Ã£o do servidor



/** 

module.exports = (io) => {
  const salas = {};

  io.on("connection", (socket) => {
    console.log(`ðŸŽ® Novo jogador conectado: ${socket.id}`);

    // Criar uma nova sala
    socket.on("criarSala", ({ idJogador, nicknameJogador }, callback) => {
      const idSala = "sala-123456";
      salas[idSala] = {
        jogador1: { id: idJogador, nickname: nicknameJogador, simbolo: "X" },
        jogador2: null,
        tabuleiro: Array(9).fill(null),
        emAndamento: true,
      };

      socket.join(idSala);
      console.log(`ðŸŸ¢ Sala criada: ${idSala}`);
      callback({ sucesso: true, idSala, idJogador });
    });

    // Entrar em uma sala existente
    socket.on(
      "entrarSala",
      ({ idSala, idJogador, nicknameJogador }, callback) => {
        console.log("ID_SALA recebido: ", idSala);
        console.log("Salas disponÃ­veis: ", salas);

        const sala = salas[idSala];
        if (!sala) {
          console.error(
            `Sala com ID ${idSala} nÃ£o encontrada. Salas disponÃ­veis:`,
            salas
          );
          return callback({ sucesso: false, mensagem: "Sala nÃ£o encontrada." });
        }

        if (sala.jogador1.id === idJogador) {
          console.error(
            `Jogador que criou a sala estÃ¡ tentando entrar novamente.`
          );
          return callback({
            sucesso: false,
            mensagem: "VocÃª jÃ¡ estÃ¡ na sala.",
          });
        }

        if (sala.jogador2) {
          console.error(`Sala com ID ${idSala} jÃ¡ estÃ¡ cheia.`);
          return callback({ sucesso: false, mensagem: "Sala cheia." });
        }

        sala.jogador2 = {
          id: idJogador,
          nickname: nicknameJogador,
          simbolo: "O",
        };
        socket.join(idSala);
        console.log(`ðŸ”µ Jogador entrou na sala: ${idSala}`);

        io.to(idSala).emit("atualizarSala", sala);
        console.log(`ðŸ”„ Sala atualizada: ${idSala}`, sala);
        callback({ sucesso: true, idSala });
      }
    );
    // Receber a jogada do jogador
    socket.on("fazerJogada", ({ idSala, index, idJogador }) => {
      const sala = salas[idSala];
      if (!sala || !sala.emAndamento) return;

      const jogadorAtual =
        idJogador === sala.jogador1.id ? sala.jogador1 : sala.jogador2;
      if (sala.tabuleiro[index] !== null) return; // PosiÃ§Ã£o jÃ¡ ocupada

      sala.tabuleiro[index] = jogadorAtual.simbolo;
      io.to(idSala).emit("atualizarTabuleiro", sala.tabuleiro);

      if (verificarVencedor(sala.tabuleiro)) {
        sala.emAndamento = false;
        io.to(idSala).emit("fimDeJogo", {
          vencedor: jogadorAtual.nickname,
        });
      } else if (sala.tabuleiro.every((c) => c !== null)) {
        sala.emAndamento = false;
        io.to(idSala).emit("fimDeJogo", { vencedor: null }); // Empate
      }
    });

    // Jogador desconectado
    socket.on("disconnect", () => {
      console.log(`ðŸ”´ Jogador desconectado: ${socket.id}`);
      for (const [idSala, sala] of Object.entries(salas)) {
        if (sala.jogador1?.id === socket.id) {
          io.to(idSala).emit("jogadorDesconectou", { jogador: sala.jogador1 });
          delete salas[idSala];
          break;
        } else if (sala.jogador2?.id === socket.id) {
          io.to(idSala).emit("jogadorDesconectou", { jogador: sala.jogador2 });
          sala.jogador2 = null;
          break;
        }
      }
    });
  });
 

  // FunÃ§Ã£o auxiliar para verificar o vencedor
  function verificarVencedor(tabuleiro) {
    const combinacoesVencedoras = [
      [0, 1, 2],
      [3, 4, 5],
      [6, 7, 8], // Linhas
      [0, 3, 6],
      [1, 4, 7],
      [2, 5, 8], // Colunas
      [0, 4, 8],
      [2, 4, 6], // Diagonais
    ];

    return combinacoesVencedoras.some(
      ([a, b, c]) =>
        tabuleiro[a] &&
        tabuleiro[a] === tabuleiro[b] &&
        tabuleiro[a] === tabuleiro[c]
    );
  }
};
 **/

 const player2 = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZEpvZ2Fkb3IiOjQsImlhdCI6MTc0MjkzNzIzMCwiZXhwIjoxNzQyOTQ0NDMwfQ.qaqP_JTVDI_6q_tS_AKTVNE0lNOK3CKHOdN3HdKNXkk';

const player1 = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZEpvZ2Fkb3IiOjMsImlhdCI6MTc0MjkzNzIwNywiZXhwIjoxNzQyOTQ0NDA3fQ.d8z6g_OR5buV3HDSbd6KAKpYDJh2pmyZyEWVMIw_eRk';